import csv
from pathlib import Path
import yaml

# NOTE:
# - We intentionally do NOT hardcode `configfile:` here.
# - Use `gmv run --config <...>` which passes `--configfile` and `config_dir`.
# - If you call snakemake directly, pass `--configfile` and ensure relative paths
#   in config are resolvable from `config_dir`.

if "execution" not in config:
    raise ValueError("未加载配置：请使用 gmv run 或 snakemake --configfile <config.yaml>")

EXEC = config["execution"]
RUN_ID = EXEC["run_id"]
TOOLS = config.get("tools", {}).get("enabled", {})
MOCK_MODE = bool(EXEC.get("mock_mode", False))
DEFAULT_THREADS = int(config.get("resources", {}).get("default_threads", 1))
THREADS_MAP = config.get("resources", {}).get("threads", {}) or {}

CONFIG_DIR = Path(config.get("config_dir", ".")).expanduser().resolve()
REPO_ROOT = Path(workflow.basedir).resolve().parent
CONTAINER_RUNTIME = str(config.get("container_runtime", EXEC.get("container_runtime", "singularity")))
GMV_PYTHONPATH = str((REPO_ROOT / "src").resolve())
WORK_ROOT = str(EXEC.get("work_dir", "work"))
RESULTS_ROOT = str(EXEC.get("results_dir", "results"))


def _resolve_from(base: Path, value: str) -> Path:
    p = Path(value).expanduser()
    return p if p.is_absolute() else (base / p).resolve()


# Resolve containers mapping
mapping_file = _resolve_from(CONFIG_DIR, config["containers"]["mapping_file"])
with open(mapping_file, "r", encoding="utf-8") as _mf:
    IMAGES = (yaml.safe_load(_mf) or {}).get("images", {})
IMAGES = {k: str(_resolve_from(mapping_file.parent, v)) for k, v in IMAGES.items()}

# Resolve databases (strings only)
DB = {
    k: str(_resolve_from(CONFIG_DIR, v))
    for k, v in (config.get("database", {}) or {}).items()
    if isinstance(v, str)
}

# Resolve sample sheet path
sample_sheet = _resolve_from(CONFIG_DIR, EXEC["sample_sheet"])

SAMPLE_META = {}
with open(sample_sheet, "r", encoding="utf-8") as fh:
    reader = csv.DictReader(fh, delimiter="\t")
    for row in reader:
        SAMPLE_META[row["sample"]] = row

SAMPLES = sorted(SAMPLE_META)
if not SAMPLES:
    raise ValueError("sample_sheet 中没有样本")


def _bind_dir(p: Path) -> str:
    p = p.expanduser().resolve()
    if p.is_file():
        p = p.parent
    return str(p)


def _auto_bind_paths() -> list[str]:
    paths: set[str] = set()

    # Always bind the repo root to keep relative work/results resolvable.
    paths.add(_bind_dir(REPO_ROOT))
    paths.add(_bind_dir(CONFIG_DIR))
    paths.add(_bind_dir(sample_sheet.parent))

    # Bind work/results roots (usually inside repo root).
    paths.add(_bind_dir(_resolve_from(REPO_ROOT, WORK_ROOT)))
    paths.add(_bind_dir(_resolve_from(REPO_ROOT, RESULTS_ROOT)))

    # Bind DB roots.
    for v in DB.values():
        paths.add(_bind_dir(Path(v)))

    # Bind input directories from sample sheet.
    for row in SAMPLE_META.values():
        for key in ("input1", "input2"):
            v = (row.get(key) or "").strip()
            if not v:
                continue
            p = Path(v).expanduser()
            if not p.is_absolute():
                p = (sample_sheet.parent / p).resolve()
            paths.add(_bind_dir(p.parent))

    return sorted(paths)


def _bind_args() -> str:
    user_binds = config.get("containers", {}).get("binds", []) or []
    if not isinstance(user_binds, list):
        user_binds = [str(user_binds)]
    binds: list[str] = []
    binds.extend([b for b in user_binds if str(b).strip()])
    binds.extend(_auto_bind_paths())
    # Keep order deterministic to reduce commandline churn.
    uniq: list[str] = []
    seen: set[str] = set()
    for b in binds:
        if b not in seen:
            uniq.append(b)
            seen.add(b)
    return " ".join([f"-B {b}" for b in uniq]).strip()


BIND_ARGS = _bind_args()


def threads_for(tool: str, default: int = DEFAULT_THREADS) -> int:
    try:
        v = THREADS_MAP.get(tool, default)
        return max(1, int(v))
    except Exception:
        return int(default)

DOWNSTREAM_METHODS = []
if TOOLS.get("coverm", False):
    DOWNSTREAM_METHODS.append("coverm")
if TOOLS.get("bowtie2_samtools", False):
    DOWNSTREAM_METHODS.append("bowtie2_samtools")
if not DOWNSTREAM_METHODS:
    DOWNSTREAM_METHODS.append("coverm")


def meta(sample):
    return SAMPLE_META[sample]


def sample_mode(sample):
    return meta(sample).get("mode", "reads")


def raw_input1(sample):
    p = Path(meta(sample)["input1"]).expanduser()
    # Relative paths in sample sheet are resolved against the sample sheet directory.
    return str(p if p.is_absolute() else (sample_sheet.parent / p).resolve())


def raw_input2(sample):
    v = meta(sample).get("input2", "")
    if not v:
        return ""
    p = Path(v).expanduser()
    return str(p if p.is_absolute() else (sample_sheet.parent / p).resolve())


def host_name(sample):
    return meta(sample).get("host", "")


def step_dir(sample, step):
    return f"{WORK_ROOT}/{RUN_ID}/upstream/{sample}/{step}"


def result_dir(sample, step):
    return f"{RESULTS_ROOT}/{RUN_ID}/upstream/{sample}/{step}"


def detect_outputs(sample):
    outs = []
    if TOOLS.get("virsorter", False):
        outs.append(f"{WORK_ROOT}/{RUN_ID}/upstream/{sample}/5.virsorter/contigs.fa")
    if TOOLS.get("genomad", False):
        outs.append(f"{WORK_ROOT}/{RUN_ID}/upstream/{sample}/6.genomad/contigs.fa")
    return outs


def tool_cmd(tool_name):
    image = IMAGES.get(tool_name, "")
    if EXEC.get("use_singularity", True) and image:
        return f"{CONTAINER_RUNTIME} exec {BIND_ARGS} {image} {tool_name}".strip()
    return tool_name


include: "rules/upstream.smk"
include: "rules/viruslib.smk"
include: "rules/downstream.smk"
include: "rules/agent.smk"


ALL_TARGETS = []
ALL_TARGETS += expand(f"{RESULTS_ROOT}/{RUN_ID}/upstream/{{sample}}/11.busco_filter/contigs.fa", sample=SAMPLES)
ALL_TARGETS += [f"{RESULTS_ROOT}/{RUN_ID}/viruslib/viruslib_nr.fa"]
ALL_TARGETS += expand(f"{RESULTS_ROOT}/{RUN_ID}/downstream/{{method}}/abundance.tsv", method=DOWNSTREAM_METHODS)
ALL_TARGETS += [f"{RESULTS_ROOT}/{RUN_ID}/agent/decisions.jsonl"]
if TOOLS.get("phabox2", False):
    ALL_TARGETS += [f"{RESULTS_ROOT}/{RUN_ID}/viruslib/phabox2/summary.tsv"]


rule all:
    input:
        ALL_TARGETS
